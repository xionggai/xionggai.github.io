<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>




  <meta name="keywords" content="javascript," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'hide'
  };
</script>




  <title> JavaScript读书笔记08 // 能不能改 </title>
</head>

<body>
  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->

  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">能不能改</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<div class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            <i class="menu-item-icon icon-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
    </ul>
  

  
</div>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              JavaScript读书笔记08
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-12
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/JavaScript/">JavaScript</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/12/JavaScript读书笔记08/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/12/JavaScript读书笔记08/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h2 id="JavaScript面向对象">JavaScript面向对象</h2><h3 id="面向对象">面向对象</h3><p>引用类型的实例就是对象，创建对象很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> zhangsan = &#123;</span><br><span class="line">	name: <span class="string">"zhangsan"</span>,</span><br><span class="line">	age: <span class="number">18</span>,</span><br><span class="line">	tellName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Javascript中的对象的定义是：<code>无序属性的集合，其属性可以包含基本值、对象或者函数</code>。这和其他的面向对象的语言是有很大的差别，其他的面向对象语言中有两个很重要的概念，类和实例，类就是对象的模板，实例就是根据模板创建的对象。而在JavaScript中并没有类的概念。所以如果现在需要创建另外一个对象<code>lisi</code>，而<code>lisi</code>和<code>zhangsan</code>一样，也有相同的属性，应该怎么去做。这里就需要一个同类型的模板，在JavaScript中，用<strong>原型（prototype）</strong>来实现面向对象。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">	name: <span class="string">"zhangsan"</span>,</span><br><span class="line">	age: <span class="number">0</span>,</span><br><span class="line">	tellName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = &#123;</span><br><span class="line">	name: <span class="string">"zhangsan"</span>,</span><br><span class="line">	age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lisi = &#123;</span><br><span class="line">	name: <span class="string">"lisi"</span>,</span><br><span class="line">	age: <span class="number">13</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zhangsan.__proto__ = Person;</span><br><span class="line">lisi.__proto__ = Person;</span><br><span class="line"></span><br><span class="line">zhangsan.tellName();</span><br><span class="line">lisi.tellName();</span><br></pre></td></tr></table></figure>
<p>在上面的例子中使用了<code>__proto__</code>属性，这是对象的一个属性，是一个指向原型对象的指针，修改了原型对象，也就具有了原型对象中的方法，所以<code>Person</code>就成为了<code>zhangsan</code>和<code>lisi</code>的共同的模板。</p>
<p>需要特别说明的是，<strong>ECMASript中管这个指向原型对象的指针为[[prototype]]，但并没有标准的访问方式，而这里的<code>__proto__</code>是在FixFox，Chrome和Safari所共同支持的</strong></p>
<h3 id="创建对象">创建对象</h3><p>上面提到了原型的概念，也用到了<code>__proto__</code>属性，但实际中并不会用到该属性去修改原型对象，为了更好的理解原型的概念，下面还是从创建对象开始说起。依旧是为了解决具有共同属性的一些对象，我们如何创建一个模板，让创建对象变的更加轻松。</p>
<h4 id="工厂模式">工厂模式</h4><p>工厂模式就是一种创建具体对象的设计模式，因为没有类的概念，所以发明一种函数，封装所有创建对象的细节：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> someone = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	someone.name = name;</span><br><span class="line">	someone.age = age;</span><br><span class="line">	someone.tellName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> someone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = createPerson(<span class="string">"zhangsan"</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> lisi = createPerson(<span class="string">"lisi"</span>, <span class="number">13</span>);</span><br></pre></td></tr></table></figure>
<p>工厂模式很好的解决了创建一类对象的需求，但是还有个问题不能解决，就是对象的识别问题，这里很难知道<code>zhangsan</code>,<code>lisi</code>是什么类型的。</p>
<h4 id="构造函数模式">构造函数模式</h4><p>前面提到过构造函数就是一类特殊的函数，专门用来创建特定类型的对象，并且需要用new来调用。之前介绍过原生的构造函数，例如<code>Object()</code>,<code>Array()</code>。这里需要创建自定义的构造函数，从而定义自定义对象的属性和方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.tellName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> lisi = <span class="keyword">new</span> Person(<span class="string">"lisi"</span>, <span class="number">13</span>);</span><br></pre></td></tr></table></figure>
<p>构造函数和工厂模式的普通函数相比，有如下的特点：</p>
<ul>
<li>没有显示的创建对象</li>
<li>直接将方法和属性赋值给this</li>
<li>没有return语句</li>
<li>方法名首字母大写</li>
</ul>
<p>构造函数的调用也会经历下面4个过程</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（因此this指向了新对象）</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ol>
<p>构造函数模式就很好的解决了面向对象的问题，现在也可以验证对象所属的类型:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = zhangsan <span class="keyword">instanceof</span> Person;		<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> res = lisi <span class="keyword">instanceof</span> Person;		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>并且每个对象都有一个属性指向它的构造函数<code>constructor</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(zhangsan.constructor == Person);		<span class="comment">//true</span></span><br><span class="line">alert(lisi.constructor == Person);		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="构造函数当做普通函数">构造函数当做普通函数</h4><p>前文提到了构造函数和普通函数的4个区别，但这些区别只是我们观察到的区别，而不是解释器用来识别构造函数的依据。解释器是被构造函数的唯一依据是调用的方式，也就是是不是通过<code>new</code>调用的。具体的说，任何函数，只要通过new调用，那么它就是构造函数，反之则不是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.tellName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = Person(<span class="string">"zhangsan"</span>, <span class="number">18</span>);</span><br><span class="line">Person(<span class="string">"lisi"</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">zhangsan.tellName();			<span class="comment">//error: zhangsan is undefined</span></span><br><span class="line"><span class="built_in">window</span>.tellName();			<span class="comment">//My name is lisi</span></span><br></pre></td></tr></table></figure>
<p>这里需要回顾一下函数的内部属性之一<code>this</code>（另一个是<code>arguments</code>），<code>this</code>总是指向调用函数的对象，所以全局函数的this指向全局对象，这里就是<code>window</code>。</p>
<h4 id="构造函数的问题">构造函数的问题</h4><p>构造函数的最主要的问题在于对于函数属性的问题，构造函数为每一个实例创建了函数属性都创建了一个新的<code>Function</code>实例，也就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(zhangsan.tellName == lisi.tellName);	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>为相同的任务而创建了两个完全一样的Function实例确实没有必要，所以可以把函数定义放到构造函数外面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.tellName = tellName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tellName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"My name is "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> lisi = <span class="keyword">new</span> Person(<span class="string">"lisi"</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">alert(zhangsan.tellName == lisi.tellName)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>这样解决了函数属性的问题，新的问题又随之而来。解决的办法实际上是把属于某个类的函数，为了实现所有实例都共享一个函数的目的，而强行的放到了全局环境中。产生两个问题：</p>
<ul>
<li>全局函数名不副实，只能被某些对象所调用；</li>
<li>自定义的类型毫无封装性而言。</li>
</ul>
<p>这些问题，都得通过原型模式来解决。</p>
<h3 id="原型模式">原型模式</h3><p>构造函数的问题在于共享的函数不知道该放到哪，放到构造函数本身就会重复创建函数对象，放到全局环境则影响封装，而这里就引入了一个专门的对象，来存放一类对象公有的属性和方法。我们创建的每一个函数，都会有一个<code>prototype</code>（原型）属性，这属性是一个指针，指向一个对象，而这个对象就包含了可以由特定的类型的所有实例所共享的属性和方法。也就是prototype指向的对象就是构造函数创建的对象的<strong>原型对象</strong>，这里就是共享的方法和属性所在的位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">0</span>;</span><br><span class="line">Person.prototype.tellName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> Person();</span><br><span class="line">zhangsan.tellName();</span><br><span class="line"><span class="keyword">var</span> lisi = <span class="keyword">new</span> Person();</span><br><span class="line">lisi.tellName();</span><br><span class="line"></span><br><span class="line">alert(zhangsan.tellName == lisi.tellName);	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>创建的新对象都共享了设置在<code>prototype</code>的属性和方法。</p>
<h4 id="理解原型模式">理解原型模式</h4><p>无论什么时候，只要创建了函数，就会根据一组特定的规则为该函数创建一个<code>prototype</code>的属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象自动获得一个<code>constructor</code>的属性，该属性包含一个指针，反过来指向函数。也就是<code>Person.prototype.constructor</code>指向<code>Person</code>。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得<code>constructor</code>的属性，其他属性都从<code>Object</code>继承而来。当调用构造函数创建一个实例后，该实例的内部包含一个指针（内部属性），指向构造函数的原型对象，管这个指针叫做<code>[[prototype]]</code>，也就是上文中用到的<code>__proto__</code>属性。如下图展示了各个对象之间的关系：<br><img src="http://7xkbic.com1.z0.glb.clouddn.com/prototype.png" alt="prototype"></p>
<h4 id="原型链">原型链</h4><p>之前用到的<code>__prototype__</code>属性并不是标准的访问途径，关于对象和其原型之间的联系，标准定义了两个方法:</p>
<ul>
<li><code>isPrototypeOf</code>:判断是不是原型和对象的关系</li>
<li><code>getPrototypeOf</code>:获得对象的原型对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.isPrototypeOf(zhangsan);		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(zhangsan) == Person.prototype;	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(zhangsan).name;			<span class="comment">//"zhangsan"</span></span><br></pre></td></tr></table></figure>
<p>创建的对象其实并没有name等属性，但是也可以访问，这是通过查找对象的属性的过程来实现的。当访问一个对象的属性时，解释器首先会在该对象上找对应的属性，如果没有则会继续在它的原型对象上找，如果还是没有就继续往上找原型对象的原型对象，一直到<code>Object</code>的<code>prototype</code>，如果还没找到才返回<code>undefined</code>。这个搜索的链就是原型链：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">zhangsan --<span class="subst">-&gt; </span>Person<span class="built_in">.</span>prototype --<span class="subst">-&gt; </span>Object<span class="built_in">.</span>prototype --<span class="subst">-&gt; </span><span class="built_in">null</span></span><br></pre></td></tr></table></figure>
<p>这就解释了为什么zhangsan上可以访问<code>name</code>属性，也可以访问<code>Object</code>原型上定义的属性.<br>也可以推论出，在新建的对象上定义同样的属性并不是修改原型中的属性，但会覆盖掉，在该对象上就相当于是屏蔽了原型中的对应属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lisi.name = <span class="string">"lisi"</span>;</span><br><span class="line"></span><br><span class="line">alert(zhangsan.name);		<span class="comment">//"zhangsan"——来自原型</span></span><br><span class="line">alert(lisi.name);		<span class="comment">//"lisi"——来自实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>(lisi.name);</span><br><span class="line">alert(lisi.name);		<span class="comment">//"zhangsan"——来自原型</span></span><br></pre></td></tr></table></figure>
<h4 id="属性来自">属性来自</h4><p>访问一个对象的属性时，这个属性既可能是来自对象本身，也可以是来自其原型对象，如何去区分一个属性到底来自哪里：</p>
<ul>
<li><code>hasOwnProperty()</code>：确定属性是不是来自对象本身</li>
<li><code>in</code>：确定整个原型链上是不是存在该属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> zhangsan.name;</span><br><span class="line"><span class="keyword">delete</span> lisi.name;</span><br><span class="line"></span><br><span class="line">lisi.hasOwnProperty(<span class="string">"name"</span>);	<span class="comment">//false</span></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> lisi);		<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">lisi.name = <span class="string">"lisi"</span>;</span><br><span class="line"></span><br><span class="line">lisi.hasOwnProperty(<span class="string">"name"</span>);	<span class="comment">//true</span></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> lisi);		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>结合这两个方法就可以判断属性是来自对象本身还是其原型对象了。</p>
<h4 id="构造函数模式和原型模式的结合">构造函数模式和原型模式的结合</h4><p>上面的例子我们也看到了原型模式的缺点，原型对象就是一个共享属性的存放地，一个实例对象的属性究竟是来自自身还是来自其原型对象是不确定的。对于属性是基本值的情况还是可以接受的，就如上面的例子，给新的对象添加同名属性时，可以隐藏原型对象的属性。然而对于属性是引用类型的情况，问题就变的不能接受了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">0</span>;</span><br><span class="line">Person.prototype.friends = [<span class="string">"wangwu"</span>];</span><br><span class="line">Person.prototype.tellName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> lisi = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">zhangsan.friends.push(<span class="string">"zhaoliu"</span>);</span><br><span class="line">alert(lisi.friends);				<span class="comment">//["wangwu", "zhaoliu"]</span></span><br></pre></td></tr></table></figure>
<p>给<code>zhangsan</code>增加了一个朋友，结果由于属性书共享在原型对象上的，所以全部的实例都增加了这个朋友，这显然是不能接受的。<br>构造函数模式的问题是所有的实例都有一份自己的属性，而原型模式的问题是所有的属性都共享在原型对象上，所以其实可以把它们很好的结合起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.friends = [<span class="string">"wangwu"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.tellName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以很好的解决方法的共享和属性的隔离了。</p>
<h4 id="简化原型模式的写法">简化原型模式的写法</h4><p>上面我们基本解决了创建对象的问题，通过构造函数和原型模式，还有最后一个问题，就是针对原型模式，写法比较复杂，每次给原型对象增加属性或者方法就得重新写一遍<code>xxx.prototype.xxx = &quot;xxx&quot;</code>，我们试图把所有的属性一次性的赋值：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">	tellName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;,</span><br><span class="line">	sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">"hello I am "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样导致的问题是并不是去给<code>Person.prototype</code>增加方法，而是直接替换了，这样<code>Perosn.prototype</code>的<code>constructor</code>就不再指向<code>Person</code>了，而是指向<code>Object</code>,所以需要专门设定:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">	constructor: Person,</span><br><span class="line">	tellName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;,</span><br><span class="line">	sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">"hello I am "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/"> #javascript </a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/08/19/Think-Functionally/">Think Functionally</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/06/30/JavaScript读书笔记07/">JavaScript读书笔记07</a>
            
          </div>
        </div>
      

      
      
    </div>
  </div>



    <div class="post-spread">
      
    </div>

    
      <div class="comments" id="comments">
        
          <div class="ds-thread" data-thread-key="2015/07/12/JavaScript读书笔记08/"
               data-title="JavaScript读书笔记08" data-url="http://xionggai.github.com/2015/07/12/JavaScript读书笔记08/">
          </div>
        
      </div>
    
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="http://tp4.sinaimg.cn/1888998427/180/5612230201/1" alt="xionggai" />
          <p class="site-author-name">xionggai</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/hustphysics" target="_blank">Weibo</a>
            </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>
        
      </div>

      
        <div class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript面向对象"><span class="nav-number">1.</span> <span class="nav-text">JavaScript面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象"><span class="nav-number">1.1.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象"><span class="nav-number">1.2.</span> <span class="nav-text">创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#工厂模式"><span class="nav-number">1.2.1.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数模式"><span class="nav-number">1.2.2.</span> <span class="nav-text">构造函数模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数当做普通函数"><span class="nav-number">1.2.3.</span> <span class="nav-text">构造函数当做普通函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数的问题"><span class="nav-number">1.2.4.</span> <span class="nav-text">构造函数的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型模式"><span class="nav-number">1.3.</span> <span class="nav-text">原型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#理解原型模式"><span class="nav-number">1.3.1.</span> <span class="nav-text">理解原型模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型链"><span class="nav-number">1.3.2.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性来自"><span class="nav-number">1.3.3.</span> <span class="nav-text">属性来自</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数模式和原型模式的结合"><span class="nav-number">1.3.4.</span> <span class="nav-text">构造函数模式和原型模式的结合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简化原型模式的写法"><span class="nav-number">1.3.5.</span> <span class="nav-text">简化原型模式的写法</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </div>
      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">xionggai</span>
</div>




      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.3"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.3"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.3" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.3" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"xionggai"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  

</body>
</html>
